# Implementation Tasks: Live Excel Processing Visualization

**Feature**: 002-live-excel-processing  
**Date**: October 23, 2025  
**Status**: Ready for Implementation

## Overview

This document breaks down the implementation into discrete, testable tasks organized by user story. Tasks are sequenced to maximize parallel development opportunities while respecting dependencies.

**Legend**:

*   **\[P\]** = Parallelizable (can be worked on simultaneously with other \[P\] tasks)
*   **\[Story: US#\]** = Maps to user story in spec.md
*   **Dependencies** = Must complete before starting this task

---

## Phase 1: Project Setup & Infrastructure

### T001 - Create Feature Branch and Directory Structure \[P\]

**Description**: Set up branch and create empty module directories for new code.

**Story**: Foundation for all user stories

**Steps**:

1.  Ensure on `002-live-excel-processing` branch (already created)
2.  Create empty `src/excel/__init__.py`
3.  Verify `src/ui/` directory exists (already present)
4.  Create empty `tests/unit/` files for new tests
5.  Create `tests/fixtures/excel/` directory for test files

**Acceptance Criteria**:

*   Directory structure matches plan.md
*   All `__init__.py` files created
*   No import errors when importing new modules

**Estimated Time**: 15 minutes

**Dependencies**: None

---

### T002 - Update .github/copilot-instructions.md \[P\]

**Description**: Update agent context with new tech stack and structure.

**Story**: Foundation

**Steps**:

1.  Add "Python 3.11+ + tkinter (GUI), openpyxl (Excel), agent-framework-azure-ai (multi-agent)" to Active Technologies
2.  Add "Excel files (.xlsx) on local filesystem" to Active Technologies
3.  Update project structure section with new src/excel/ and src/ui/ files
4.  Commit changes

**Acceptance Criteria**:

*   .github/copilot-instructions.md reflects current architecture
*   No merge conflicts with existing content

**Estimated Time**: 10 minutes

**Dependencies**: None

---

## Phase 2: Core Data Structures (Foundational)

### T003 - Implement CellState Enum

**Description**: Create enum for cell processing states.

**Story**: Foundation for US2, US3

**Steps**:

1.  Open `src/utils/data_types.py`
2.  Add `from enum import Enum` import
3.  Define `CellState` enum with PENDING, WORKING, COMPLETED values
4.  Add docstring explaining state transitions

**Acceptance Criteria**:

*   CellState.PENDING.value == "pending"
*   CellState.WORKING.value == "working"
*   CellState.COMPLETED.value == "completed"
*   No import errors

**Estimated Time**: 10 minutes

**Dependencies**: T001

---

### T004 - Implement SheetData Dataclass

**Description**: Create dataclass for single sheet representation.

**Story**: Foundation for US1, US4

**Steps**:

1.  Add SheetData dataclass to `src/utils/data_types.py`
2.  Include fields: sheet\_name, sheet\_index, questions, answers, cell\_states, is\_processing, is\_complete
3.  Add `__post_init__` validation for list length invariants
4.  Implement `get_progress()` method returning completion percentage

**Acceptance Criteria**:

*   All fields defined with correct types
*   Invariant validation raises AssertionError if lists differ in length
*   get\_progress() returns 0.0 for empty sheet, 1.0 for all completed
*   Dataclass can be instantiated successfully

**Estimated Time**: 30 minutes

**Dependencies**: T003

---

### T005 - Implement WorkbookData Dataclass

**Description**: Create dataclass for entire workbook.

**Story**: Foundation for US1, US4, US7

**Steps**:

1.  Add WorkbookData dataclass to `src/utils/data_types.py`
2.  Include fields: file\_path, sheets, current\_sheet\_index
3.  Add properties: total\_questions, completed\_questions
4.  Implement `get_active_sheet()` method

**Acceptance Criteria**:

*   All fields defined with correct types
*   Properties compute correct totals across all sheets
*   get\_active\_sheet() returns sheet with is\_processing=True or None
*   Dataclass can be instantiated with multiple sheets

**Estimated Time**: 30 minutes

**Dependencies**: T004

---

### T006 - Implement NavigationState Dataclass

**Description**: Create dataclass for tracking user sheet navigation.

**Story**: US6

**Steps**:

1.  Add NavigationState dataclass to `src/utils/data_types.py`
2.  Include fields: user\_selected\_sheet (Optional\[int\])
3.  Add property: auto\_navigation\_enabled
4.  Implement methods: lock\_to\_sheet(), enable\_auto\_navigation()

**Acceptance Criteria**:

*   auto\_navigation\_enabled returns True when user\_selected\_sheet is None
*   lock\_to\_sheet(idx) sets user\_selected\_sheet
*   enable\_auto\_navigation() clears user\_selected\_sheet
*   State correctly reflects navigation control

**Estimated Time**: 20 minutes

**Dependencies**: T003

---

### T007 - Implement UIUpdateEvent Dataclass

**Description**: Create dataclass for UI update events from background thread.

**Story**: Foundation for US2, US3, US4, US5

**Steps**:

1.  Add UIUpdateEvent dataclass to `src/utils/data_types.py`
2.  Include fields: event\_type (str), payload (Dict\[str, Any\]), timestamp (float)
3.  Add default\_factory for timestamp using time.time()
4.  Document event types in docstring: SHEET\_START, CELL\_WORKING, CELL\_COMPLETED, SHEET\_COMPLETE, WORKBOOK\_COMPLETE, ERROR

**Acceptance Criteria**:

*   Dataclass can be instantiated with any event\_type and payload
*   Timestamp automatically populated on creation
*   Docstring lists all event types

**Estimated Time**: 20 minutes

**Dependencies**: T003

---

### T008 - Create Unit Tests for Data Types \[P\]

**Description**: Write comprehensive unit tests for all new data structures.

**Story**: Foundation

**Steps**:

1.  Create `tests/unit/test_data_types.py`
2.  Test CellState enum values
3.  Test SheetData creation, validation, and get\_progress()
4.  Test WorkbookData properties and get\_active\_sheet()
5.  Test NavigationState state transitions
6.  Test UIUpdateEvent creation with timestamp

**Acceptance Criteria**:

*   All data type tests pass
*   Coverage includes edge cases (empty lists, None values)
*   Tests verify invariant violations raise errors

**Estimated Time**: 45 minutes

**Dependencies**: T003-T007

---

## Phase 3: User Story 1 - View Live Spreadsheet (P1)

### T009 - Implement ExcelLoader.load\_workbook()

**Description**: Load Excel file and extract questions from all visible sheets.

**Story**: US1

**Steps**:

1.  Create `src/excel/loader.py`
2.  Implement ExcelLoader class
3.  Implement load\_workbook(file\_path) method using openpyxl
4.  Read questions from column A (starting row 2)
5.  Skip hidden sheets (sheet\_state != 'visible')
6.  Return WorkbookData with all sheets
7.  Raise FileNotFoundError or ExcelFormatError on failures

**Acceptance Criteria**:

*   Loads valid .xlsx files successfully
*   Extracts questions from column A
*   Skips hidden sheets and logs warning
*   Raises appropriate exceptions for invalid files
*   Returns WorkbookData with correct sheet count

**Estimated Time**: 1.5 hours

**Dependencies**: T005

---

### T010 - Create Test Fixtures for Excel Files \[P\]

**Description**: Create sample Excel files for testing.

**Story**: US1, US4

**Steps**:

1.  Create `tests/fixtures/excel/` directory
2.  Create `single_sheet_5_questions.xlsx` with 5 questions in Sheet1
3.  Create `multi_sheet_3x10_questions.xlsx` with 3 sheets, 10 questions each
4.  Create `hidden_sheets.xlsx` with 1 visible + 1 hidden sheet
5.  Create `invalid_format.txt` (non-Excel file)
6.  Create `empty_sheets.xlsx` with sheets containing no questions

**Acceptance Criteria**:

*   All fixture files created and committed
*   Files loadable with openpyxl
*   Cover edge cases (hidden, empty, invalid)

**Estimated Time**: 30 minutes

**Dependencies**: T001

---

### T011 - Create Unit Tests for ExcelLoader \[P\]

**Description**: Test Excel loading with various file formats.

**Story**: US1

**Steps**:

1.  Create `tests/unit/test_excel_loader.py`
2.  Test loading valid single-sheet file
3.  Test loading multi-sheet file
4.  Test skipping hidden sheets
5.  Test FileNotFoundError for missing file
6.  Test ExcelFormatError for invalid format
7.  Test handling empty sheets

**Acceptance Criteria**:

*   All ExcelLoader tests pass
*   Tests use fixture files from T010
*   Edge cases covered (empty, hidden, invalid)

**Estimated Time**: 1 hour

**Dependencies**: T009, T010

---

### T012 - Implement SpreadsheetView Class

**Description**: Create tkinter Treeview-based spreadsheet renderer.

**Story**: US1

**Steps**:

1.  Create `src/ui/spreadsheet_view.py`
2.  Implement SpreadsheetView class with **init**(parent, sheet\_data)
3.  Implement render() method creating ttk.Treeview
4.  Configure columns: 'question' and 'response'
5.  Configure tags for cell states: pending, working, completed
6.  Insert all rows from sheet\_data with appropriate tags
7.  Add vertical scrollbar
8.  Store row\_ids for later updates

**Acceptance Criteria**:

*   Treeview renders with 2 columns
*   All questions from sheet\_data appear as rows
*   Tags configured with correct colors (white, pink, green)
*   Scrollbar functional
*   render() returns configured Treeview widget

**Estimated Time**: 2 hours

**Dependencies**: T004

---

### T013 - Implement SpreadsheetView.update\_cell() \[P\]

**Description**: Add method to update individual cell visual state.

**Story**: US2, US3

**Steps**:

1.  Add update\_cell(row\_index, state, answer) method to SpreadsheetView
2.  Implement \_get\_response\_text() helper for state-based text
3.  Update Treeview item with new values and tags
4.  Add logging for cell updates
5.  Handle invalid row\_index gracefully

**Acceptance Criteria**:

*   update\_cell() changes cell background and text
*   PENDING: white background, empty response
*   WORKING: pink background, "Working..." text
*   COMPLETED: green background, answer text displayed
*   Invalid row\_index logs warning without crashing

**Estimated Time**: 45 minutes

**Dependencies**: T012

---

### T014 - Create Mock UI Tests for SpreadsheetView \[P\]

**Description**: Test SpreadsheetView rendering and updates without full UI.

**Story**: US1

**Steps**:

1.  Create `tests/unit/test_ui_components.py`
2.  Create helper to instantiate SpreadsheetView with mock parent
3.  Test render() creates Treeview with correct columns
4.  Test initial rendering shows all questions
5.  Test update\_cell() changes visual state
6.  Test cell color transitions (PENDING → WORKING → COMPLETED)

**Acceptance Criteria**:

*   All SpreadsheetView tests pass
*   Tests don't require full tkinter main loop
*   Cell state transitions verified
*   Edge cases tested (invalid row\_index)

**Estimated Time**: 1.5 hours

**Dependencies**: T012, T013

---

## Phase 4: User Story 4 - Process All Sheets Sequentially (P1)

### T015 - Implement WorkbookView Class

**Description**: Create tkinter Notebook-based multi-sheet view.

**Story**: US4

**Steps**:

1.  Create `src/ui/workbook_view.py`
2.  Implement WorkbookView class with **init**(parent, workbook\_data, ui\_update\_queue)
3.  Implement render() method creating ttk.Notebook
4.  Create one SpreadsheetView per sheet in separate frames
5.  Add all frames as Notebook tabs with sheet names
6.  Bind `<<NotebookTabChanged>>` event to handle\_user\_tab\_click()
7.  Initialize NavigationState

**Acceptance Criteria**:

*   Notebook renders with one tab per sheet
*   Each tab contains a SpreadsheetView
*   Tab names match sheet names from workbook\_data
*   Tab click event bound correctly
*   render() returns configured Notebook widget

**Estimated Time**: 2 hours

**Dependencies**: T012, T006

---

### T016 - Implement WorkbookView Navigation Methods \[P\]

**Description**: Add sheet navigation and tab indicator methods.

**Story**: US4, US5, US6

**Steps**:

1.  Add navigate\_to\_sheet(sheet\_index) method to WorkbookView
2.  Check NavigationState.auto\_navigation\_enabled before navigating
3.  Use notebook.select(sheet\_index) to switch tabs
4.  Add update\_tab\_indicator(sheet\_index, is\_processing) method
5.  Update tab text with spinner character (⟳) when processing
6.  Implement handle\_user\_tab\_click() to lock navigation

**Acceptance Criteria**:

*   navigate\_to\_sheet() switches tabs when auto-navigation enabled
*   navigate\_to\_sheet() does nothing when user has locked navigation
*   update\_tab\_indicator() adds/removes spinner from tab text
*   handle\_user\_tab\_click() calls NavigationState.lock\_to\_sheet()
*   Logging indicates navigation state changes

**Estimated Time**: 1 hour

**Dependencies**: T015

---

### T017 - Implement WorkbookView UI Update Polling \[P\]

**Description**: Add queue polling for background thread events.

**Story**: US2, US3, US4, US5

**Steps**:

1.  Add start\_update\_polling() method to WorkbookView
2.  Implement \_poll\_queue() method with try/except queue.Empty
3.  Process events via \_process\_event(event)
4.  Schedule next poll with root.after(50ms)
5.  Handle event types: SHEET\_START, CELL\_WORKING, CELL\_COMPLETED, SHEET\_COMPLETE, ERROR
6.  Dispatch to appropriate methods (navigate, update\_cell, update\_tab\_indicator)

**Acceptance Criteria**:

*   Polling starts on start\_update\_polling() call
*   Polls every 50ms without blocking
*   All event types handled correctly
*   Events trigger UI updates on correct sheets/cells
*   Errors logged appropriately

**Estimated Time**: 1.5 hours

**Dependencies**: T015, T016, T007

---

### T018 - Create Unit Tests for WorkbookView \[P\]

**Description**: Test WorkbookView multi-sheet rendering and navigation.

**Story**: US4, US6

**Steps**:

1.  Add WorkbookView tests to `tests/unit/test_ui_components.py`
2.  Test render() creates Notebook with all sheets
3.  Test navigate\_to\_sheet() with auto-navigation enabled/disabled
4.  Test update\_tab\_indicator() adds/removes spinner
5.  Test handle\_user\_tab\_click() locks navigation
6.  Test \_process\_event() handles all event types

**Acceptance Criteria**:

*   All WorkbookView tests pass
*   Navigation state correctly managed
*   Tab indicators update as expected
*   Event processing verified for all types

**Estimated Time**: 2 hours

**Dependencies**: T015, T016, T017

---

### T019 - Implement ExcelProcessor Class

**Description**: Orchestrate multi-sheet processing with agent workflow.

**Story**: US4

**Steps**:

1.  Create `src/excel/processor.py`
2.  Implement ExcelProcessor class with **init**(agent\_coordinator, ui\_update\_queue)
3.  Implement async process\_workbook(workbook\_data, context, char\_limit, max\_retries)
4.  Loop through all sheets sequentially
5.  Emit SHEET\_START event for each sheet
6.  Process questions via agent\_coordinator.process\_question()
7.  Emit CELL\_WORKING before each question, CELL\_COMPLETED after
8.  Emit SHEET\_COMPLETE after each sheet, WORKBOOK\_COMPLETE at end
9.  Track statistics (processed, failed, time)

**Acceptance Criteria**:

*   Processes all sheets in workbook sequentially
*   Emits correct UIUpdateEvents at each stage
*   Integrates with existing AgentCoordinator
*   Returns ExcelProcessingResult with statistics
*   Handles errors gracefully, continues processing remaining questions

**Estimated Time**: 2.5 hours

**Dependencies**: T005, T007

---

### T020 - Create Integration Test for Excel Workflow \[P\]

**Description**: End-to-end test with mock agents processing multi-sheet Excel.

**Story**: US4

**Steps**:

1.  Create `tests/integration/test_excel_workflow.py`
2.  Create MockAgentCoordinator returning mock answers
3.  Load multi-sheet test fixture
4.  Run ExcelProcessor.process\_workbook() with mock coordinator
5.  Verify all UIUpdateEvents emitted in correct order
6.  Verify all questions processed across all sheets
7.  Verify statistics in result (processed count, time)

**Acceptance Criteria**:

*   Integration test passes with mock agents
*   All sheets processed in order
*   All expected events emitted
*   Statistics correct
*   Test completes in \<5 seconds

**Estimated Time**: 2 hours

**Dependencies**: T019, T010

---

## Phase 5: User Story 7 - Preserve Deferred Save (P1)

### T021 - Implement ExcelLoader.save\_workbook()

**Description**: Save all answers back to Excel file after processing.

**Story**: US7

**Steps**:

1.  Add save\_workbook(workbook\_data) method to ExcelLoader
2.  Re-open Excel file with openpyxl
3.  Iterate through workbook\_data.sheets
4.  Write answers to column B (row 2+) for each sheet
5.  Save workbook with wb.save(file\_path)
6.  Handle errors (file locked, format changed, IO errors)

**Acceptance Criteria**:

*   Saves answers to correct cells (column B)
*   Preserves Excel formatting and formulas
*   All sheets updated in single save operation
*   Raises IOError or ExcelFormatError on failures
*   Original file modified only on successful save

**Estimated Time**: 1 hour

**Dependencies**: T009

---

### T022 - Add Save Tests to ExcelLoader Unit Tests \[P\]

**Description**: Test saving answers back to Excel files.

**Story**: US7

**Steps**:

1.  Update `tests/unit/test_excel_loader.py`
2.  Test save\_workbook() writes answers to column B
3.  Test re-loading saved file shows answers
4.  Test save preserves formatting
5.  Test error handling (file locked, invalid path)
6.  Test multi-sheet save updates all sheets

**Acceptance Criteria**:

*   All save tests pass
*   Saved files loadable and contain correct answers
*   Formatting preserved (verify with openpyxl)
*   Error cases handled gracefully

**Estimated Time**: 1 hour

**Dependencies**: T021, T011

---

### T023 - Add Deferred Save to Integration Test \[P\]

**Description**: Verify file only saved after complete processing.

**Story**: US7

**Steps**:

1.  Update `tests/integration/test_excel_workflow.py`
2.  Check file timestamp before processing
3.  Monitor file timestamp during processing (should not change)
4.  Verify file timestamp changes only after process\_workbook() completes
5.  Verify saved file contains all answers

**Acceptance Criteria**:

*   File not modified during processing
*   File only saved after WORKBOOK\_COMPLETE event
*   All answers present in saved file

**Estimated Time**: 30 minutes

**Dependencies**: T020, T021

---

## Phase 6: User Story 2 - Show In-Progress Status (P2)

### T024 - Verify CELL\_WORKING Event Flow \[P\]

**Description**: Ensure CELL\_WORKING events correctly trigger pink cells.

**Story**: US2

**Steps**:

1.  Review ExcelProcessor.\_emit\_event() calls for CELL\_WORKING
2.  Review WorkbookView.\_process\_event() handling for CELL\_WORKING
3.  Create manual test: start processing, verify pink cells appear
4.  Add integration test verifying CELL\_WORKING events emitted for all questions

**Acceptance Criteria**:

*   CELL\_WORKING event emitted before each question processing
*   WorkbookView updates correct cell to WORKING state
*   Cell background turns pink (#FFB6C1)
*   Cell displays "Working..." text
*   Only one cell pink at a time (sequential processing)

**Estimated Time**: 1 hour

**Dependencies**: T019, T017, T013

---

### T025 - Add Visual Verification Test \[P\]

**Description**: Manual test to visually confirm pink "Working..." cells.

**Story**: US2

**Steps**:

1.  Create `tests/manual/test_visual_feedback.md` with instructions
2.  Document steps: Import multi-sheet Excel, start processing
3.  Document expected: Each cell turns pink with "Working..." before answer appears
4.  Document verification: Screenshot showing pink cell during processing
5.  Perform manual test and capture screenshot

**Acceptance Criteria**:

*   Manual test document created
*   Test performed successfully
*   Screenshot shows pink cell with "Working..." text
*   Visual feedback matches spec (pink #FFB6C1)

**Estimated Time**: 30 minutes

**Dependencies**: T024

---

## Phase 7: User Story 3 - Display Completed Answers (P2)

### T026 - Verify CELL\_COMPLETED Event Flow \[P\]

**Description**: Ensure CELL\_COMPLETED events correctly trigger green cells with answers.

**Story**: US3

**Steps**:

1.  Review ExcelProcessor.\_emit\_event() calls for CELL\_COMPLETED
2.  Review WorkbookView.\_process\_event() handling for CELL\_COMPLETED
3.  Verify answer text passed in payload
4.  Create integration test verifying CELL\_COMPLETED events include answers
5.  Add manual test verifying green cells with answer text

**Acceptance Criteria**:

*   CELL\_COMPLETED event emitted after each question completes
*   Event payload includes answer text
*   WorkbookView updates cell to COMPLETED state with answer
*   Cell background turns light green (#90EE90)
*   Cell displays actual answer text (not "Working...")

**Estimated Time**: 1 hour

**Dependencies**: T019, T017, T013

---

### T027 - Test Long Answer Text Handling \[P\]

**Description**: Verify long answers display correctly in cells.

**Story**: US3

**Steps**:

1.  Create test with mock agent returning 500+ character answer
2.  Process question and verify answer appears in cell
3.  Check Treeview column width handles long text
4.  Verify scrolling works for long text
5.  Document any truncation or wrapping behavior

**Acceptance Criteria**:

*   Long answers (500+ chars) display in cells
*   No text truncation or overflow
*   Treeview remains responsive
*   Scrollbar functional for viewing full text

**Estimated Time**: 45 minutes

**Dependencies**: T026, T013

---

## Phase 8: User Story 5 - Visual Sheet Status Indicators (P2)

### T028 - Verify Tab Spinner Display \[P\]

**Description**: Ensure spinner appears on processing sheet tabs.

**Story**: US5

**Steps**:

1.  Review WorkbookView.update\_tab\_indicator() implementation
2.  Verify SHEET\_START event triggers update\_tab\_indicator(idx, True)
3.  Verify SHEET\_COMPLETE event triggers update\_tab\_indicator(idx, False)
4.  Create manual test showing spinner on active sheet tab
5.  Verify Unicode spinner character (⟳) displays correctly

**Acceptance Criteria**:

*   Spinner appears on tab when sheet processing starts
*   Spinner disappears when sheet completes
*   Only one spinner visible at a time
*   Spinner character renders correctly (⟳ U+27F3)

**Estimated Time**: 45 minutes

**Dependencies**: T016, T017

---

### T029 - Test Spinner Across All Sheets \[P\]

**Description**: Verify spinner transitions correctly through multi-sheet processing.

**Story**: US5

**Steps**:

1.  Use 3-sheet test fixture
2.  Start processing and monitor tab indicators
3.  Verify spinner moves from Sheet 1 → Sheet 2 → Sheet 3
4.  Verify no spinner on Sheet 1 after it completes
5.  Document expected behavior in manual test

**Acceptance Criteria**:

*   Spinner appears on Sheet 1 first
*   Spinner moves to Sheet 2 after Sheet 1 completes
*   Spinner moves to Sheet 3 after Sheet 2 completes
*   No spinner on completed sheets

**Estimated Time**: 30 minutes

**Dependencies**: T028

---

## Phase 9: User Story 6 - Respect User Navigation (P2)

### T030 - Test User Tab Click Behavior \[P\]

**Description**: Verify user clicking tab disables auto-navigation.

**Story**: US6

**Steps**:

1.  Review WorkbookView.handle\_user\_tab\_click() implementation
2.  Create integration test simulating tab click event
3.  Verify NavigationState.lock\_to\_sheet() called
4.  Verify subsequent navigate\_to\_sheet() calls do nothing
5.  Create manual test: click Sheet 1 tab during Sheet 2 processing

**Acceptance Criteria**:

*   User clicking tab calls lock\_to\_sheet()
*   Auto-navigation disabled after user click
*   View remains on user-selected sheet
*   Processing continues in background (verified by completed cells)

**Estimated Time**: 1 hour

**Dependencies**: T016, T017, T006

---

### T031 - Test Navigation Lock Persistence \[P\]

**Description**: Verify navigation remains locked across multiple sheet transitions.

**Story**: US6

**Steps**:

1.  Start processing 3-sheet workbook
2.  Click Sheet 1 tab during Sheet 1 processing
3.  Wait for Sheet 2 to start (verify spinner appears on Sheet 2 tab)
4.  Verify view still shows Sheet 1 (not auto-navigated)
5.  Verify Sheet 3 start also doesn't trigger navigation

**Acceptance Criteria**:

*   User click locks navigation permanently
*   View stays on user-selected sheet through all transitions
*   Background processing completes successfully
*   All sheets show completed answers (verified by checking data)

**Estimated Time**: 45 minutes

**Dependencies**: T030

---

## Phase 10: UI Integration with UIManager

### T032 - Add WorkbookView Integration to UIManager

**Description**: Integrate WorkbookView into existing UIManager.

**Story**: US1, US4

**Steps**:

1.  Open `src/ui/main_window.py`
2.  Add imports: ExcelLoader, ExcelProcessor, WorkbookView, queue
3.  Modify \_process\_excel\_internal() to:
    *   Load workbook via ExcelLoader
    *   Create ui\_update\_queue
    *   Call \_show\_workbook\_view() on main thread
    *   Start ExcelProcessor
    *   Save workbook on completion
4.  Implement \_show\_workbook\_view(workbook\_data, ui\_queue):
    *   Hide current answer\_display
    *   Create WorkbookView
    *   Pack Notebook widget
    *   Start update polling

**Acceptance Criteria**:

*   Import Excel button triggers new workflow
*   answer\_display replaced with WorkbookView
*   Processing starts and UI updates in real-time
*   Workbook saved at end
*   No UI thread errors

**Estimated Time**: 2 hours

**Dependencies**: T015, T019, T021

---

### T033 - Handle UI Cleanup and Error States \[P\]

**Description**: Add proper cleanup when processing completes or errors.

**Story**: US1, US4, US7

**Steps**:

1.  Add \_restore\_answer\_display() method to UIManager
2.  Call from \_process\_excel\_internal() on success/error
3.  Remove WorkbookView, re-show answer\_display
4.  Display success message with statistics
5.  Handle ERROR events in WorkbookView with error dialogs
6.  Ensure resources cleaned up on window close

**Acceptance Criteria**:

*   WorkbookView removed after processing
*   answer\_display restored
*   Success message shows statistics
*   Error events trigger error dialogs
*   No resource leaks on close

**Estimated Time**: 1.5 hours

**Dependencies**: T032

---

### T034 - Create End-to-End Manual Test \[P\]

**Description**: Complete manual test with real Azure agents.

**Story**: All user stories

**Steps**:

1.  Create `tests/manual/test_end_to_end.md`
2.  Document setup: Real Azure credentials, test Excel file
3.  Document steps: Import Excel, verify UI updates, check saved file
4.  Perform test with 2-sheet, 5-question-each file
5.  Verify all acceptance criteria from spec.md

**Acceptance Criteria**:

*   Manual test document created
*   Test performed with real agents
*   All spec.md acceptance criteria verified
*   Screenshots captured for documentation

**Estimated Time**: 1 hour

**Dependencies**: T032, T033

---

## Phase 11: Testing & Polish

### T035 - Run All Unit Tests and Fix Failures \[P\]

**Description**: Execute full unit test suite and resolve any issues.

**Story**: All

**Steps**:

1.  Run `pytest tests/unit/ -v`
2.  Identify any failing tests
3.  Fix implementation or test issues
4.  Rerun until all pass
5.  Verify coverage for new modules

**Acceptance Criteria**:

*   All unit tests pass
*   No skipped tests (unless documented reason)
*   Coverage >80% for new modules

**Estimated Time**: 2 hours

**Dependencies**: All previous unit test tasks

---

### T036 - Run All Integration Tests and Fix Failures \[P\]

**Description**: Execute integration test suite and resolve issues.

**Story**: All

**Steps**:

1.  Run `pytest tests/integration/ -v`
2.  Identify any failing tests
3.  Fix implementation or test issues
4.  Verify mock agent integration
5.  Rerun until all pass

**Acceptance Criteria**:

*   All integration tests pass
*   Tests complete in \<30 seconds
*   Mock agents work correctly

**Estimated Time**: 1.5 hours

**Dependencies**: All previous integration test tasks

---

### T037 - Perform Accessibility and UX Review \[P\]

**Description**: Review UI for accessibility and user experience.

**Story**: US1, US2, US3, US5

**Steps**:

1.  Test with high-DPI display (verify scaling)
2.  Test with low-resolution display (1024x768 minimum)
3.  Verify color contrast (pink, green) for accessibility
4.  Test keyboard navigation (tab through widgets)
5.  Verify scrolling performance with 100 rows
6.  Document any UX issues

**Acceptance Criteria**:

*   UI readable on 1024x768 display
*   Colors distinguishable (WCAG AA compliant if possible)
*   Keyboard navigation functional
*   Scrolling smooth with 100 rows
*   No UX blockers identified

**Estimated Time**: 1 hour

**Dependencies**: T032

---

### T038 - Update Documentation (README, etc.) \[P\]

**Description**: Update project documentation with new feature.

**Story**: All

**Steps**:

1.  Update main README.md with "Live Excel Processing" feature description
2.  Add screenshots showing spreadsheet view
3.  Document Import Excel workflow
4.  Update requirements.txt if any dependencies changed (should not)
5.  Add CHANGES\_SUMMARY.md entry for this feature

**Acceptance Criteria**:

*   README.md describes new feature
*   Screenshots included
*   Workflow documented clearly
*   CHANGES\_SUMMARY.md updated

**Estimated Time**: 45 minutes

**Dependencies**: T032, T034

---

### T039 - Performance Testing with Large Workbooks \[P\]

**Description**: Test performance with maximum supported load.

**Story**: All (performance validation)

**Steps**:

1.  Create test Excel with 10 sheets, 100 questions each (1000 total)
2.  Run with mock agents (fast responses)
3.  Measure render time (\<2s target)
4.  Measure cell update time (\<500ms target)
5.  Measure tab navigation time (\<200ms target)
6.  Document results and any performance issues

**Acceptance Criteria**:

*   Initial render \<2s for 100 rows
*   Cell updates \<500ms
*   Tab navigation \<200ms
*   Memory usage \<10MB overhead
*   No UI freezing or lag

**Estimated Time**: 1.5 hours

**Dependencies**: T032

---

### T040 - Create Feature Demo Video \[P\]

**Description**: Record short demo video showing feature in action.

**Story**: All

**Steps**:

1.  Set up screen recording software
2.  Prepare 2-sheet Excel file with 5 questions each
3.  Record: Import Excel → Watch cells turn pink/green → Final save
4.  Show tab navigation and spinner indicators
5.  Save video to docs/ folder
6.  Add link to README.md

**Acceptance Criteria**:

*   Video \<2 minutes
*   Shows complete workflow start to finish
*   Clearly demonstrates visual feedback
*   Saved in accessible format (MP4)

**Estimated Time**: 45 minutes

**Dependencies**: T032, T034

---

## Phase 12: Final Review & Merge

### T041 - Code Review Preparation

**Description**: Prepare feature branch for code review.

**Story**: All

**Steps**:

1.  Review all code for style consistency
2.  Run ruff linter: `ruff check src/ tests/`
3.  Fix any linting issues
4.  Review all docstrings for completeness
5.  Ensure no debug prints or commented code
6.  Run all tests one final time

**Acceptance Criteria**:

*   No linting errors
*   All docstrings present
*   All tests pass
*   Code follows project conventions

**Estimated Time**: 1 hour

**Dependencies**: All previous tasks

---

### T042 - Create Pull Request

**Description**: Create PR for feature branch.

**Story**: All

**Steps**:

1.  Push final commits to `002-live-excel-processing` branch
2.  Create PR on GitHub
3.  Reference spec.md in PR description
4.  List all user stories implemented
5.  Attach screenshots and demo video
6.  Request review from team

**Acceptance Criteria**:

*   PR created with detailed description
*   All commits pushed
*   CI/CD pipeline passes (if configured)
*   Reviewers assigned

**Estimated Time**: 30 minutes

**Dependencies**: T041

---

## Task Summary

**Total Tasks**: 42  
**Estimated Total Time**: 44.5 hours

### Breakdown by Phase:

*   Phase 1 (Setup): 25 min
*   Phase 2 (Data Structures): 3 hours
*   Phase 3 (US1): 6.5 hours
*   Phase 4 (US4): 10 hours
*   Phase 5 (US7): 2.5 hours
*   Phase 6 (US2): 1.5 hours
*   Phase 7 (US3): 1.75 hours
*   Phase 8 (US5): 1.25 hours
*   Phase 9 (US6): 1.75 hours
*   Phase 10 (Integration): 4.5 hours
*   Phase 11 (Testing & Polish): 7 hours
*   Phase 12 (Final Review): 1.5 hours

### Parallelization Opportunities:

**Can work in parallel after Phase 2 complete**:

*   T009-T011 (ExcelLoader) + T012-T014 (SpreadsheetView)
*   T015-T018 (WorkbookView) + T019-T020 (ExcelProcessor)

**Can work in parallel after Phase 5 complete**:

*   T024-T025 (US2) + T026-T027 (US3) + T028-T029 (US5) + T030-T031 (US6)

**Can work in parallel after Phase 10 complete**:

*   T035-T040 (all testing and polish tasks)

---

## Dependency Graph

```
T001 → T003 → T004 → T005 → T009 → T021
                           ↘        ↗
                             T011 → T022
       ↓
     T006 → T015 → T016 → T017 → T018
             ↓
           T032 → T033 → T034
             ↓
     [All US2-US6 tasks] → T035 → T041 → T042
                       ↘
                         T036 → T037 → T038 → T039 → T040
```

---

## Risk Mitigation Tasks

### High-Risk Areas:

1.  **UI Threading** (T017, T032): Test thoroughly with asyncio integration
2.  **Performance** (T039): May need optimization if targets not met
3.  **Excel Format Handling** (T009, T021): Need robust error handling

### Mitigation Strategies:

*   Test threading patterns early (T008, T014)
*   Profile performance continuously during development
*   Use diverse Excel test fixtures (T010)

---

## Success Metrics

### Definition of Done:

*   All 42 tasks completed
*   All unit tests passing (>80% coverage)
*   All integration tests passing
*   Manual tests performed and documented
*   Performance targets met (T039)
*   Code review approved
*   PR merged to main branch

### Verification:

Run the following to verify completion:

```
# All tests pass
pytest tests/ -v

# No linting errors
ruff check src/ tests/

# Performance test
pytest tests/integration/test_excel_workflow.py -v -k "performance"
```

---

## Notes

*   **Mock Mode**: All tasks should work with mock agents (no Azure required)
*   **Incremental Testing**: Test after each phase, not just at the end
*   **Documentation**: Update docstrings as you implement, not after
*   **Git Commits**: Commit after each major task (every 2-3 hours of work)

---

**Next Steps**: Start with T001-T002 (setup), then proceed through Phase 2 (foundational data structures). Phase 3-5 implement P1 user stories, Phase 6-9 implement P2 user stories, Phase 10-11 integrate and polish, Phase 12 reviews and merges.